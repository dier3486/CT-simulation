function raw = helicalrthetatrans(img, Nrow, varargin)
% r-theta transform of the img
% raw = rthetatrans(img, center, Ntheta, d, flag_even);
% or, raw = rthetatrans(img); for lazy guy.

% image size
[Nx, Ny, Nimg] = size(img);

% default inputs
%               center        Ntheta   d        Zsample   flag_even   flag_rotdirect
defaultinput = {zeros(1, 2),  384,     1.0,     2,        true,       1              };
% input coeffients
[center, Ntheta, d, Zsample, flag_even, flag_rotdirect] = cleaninputarg(defaultinput, varargin{:});

if floor(Ntheta/Nrow) ~= Ntheta/Nrow
    % not common?
    Ntheta =
    warning('');
end

% XY grid of image
Xa = (-(Nx-1)/2 : (Nx-1)/2) - center(1, 1);
Ya = (-(Ny-1)/2 : (Ny-1)/2) - center(1, 2);
% NOTE: no movable image center (tilt) in helical
% Z grid of image (add boundry)
Za = 0:Nimg+1;

% theta grid of raw
Ntheta_all = floor(Ntheta*Nimg/Nrow);
Vb = (0 : Ntheta_all-1).*(2*pi/Ntheta).*flag_rotdirect - pi/2;
% radius grid of raw
Nb = ceil(max(Nx, Ny)/d*sqrt(2)/2)*2;
if ~flag_even
	Nb = Nb+1;
end
Rb = (-(Nb-1)/2 : (Nb-1)/2).*d;
% Z grid to shift Vb
Zsample = floor(Zsample);       % only integer
Zgrid = 0 : 1/Zsample : Nrow-1/Zsample;
Nz = Nrow*Zsample;
Vbshift = Zgrid.*(2*pi/Nrow).*flag_rotdirect;
Vb = Vb(:) - Vbshift;

% interp target (ndgrid)
Xb = Rb(:) * cos(Vb(:)');
Yb = Rb(:) * sin(Vb(:)');
Zb = repmat((0 : Ntheta_all-1).*(Nrow/Ntheta) + 1/2, Nb, Nz);
% reshape
Xb = reshape(Xb, Nb, Ntheta_all, Nz);
Yb = reshape(Yb, Nb, Ntheta_all, Nz);
Zb = reshape(Zb, Nb, Ntheta_all, Nz);

% img boundry
img = cat(3, img(:,:,1).*2-img(:,:,2), img, img(:,:,end).*2-img(:,:,end-1));
% interp 3D
raw = interp3(Xa, Ya, Za, permute(img, [2 1 3]), Xb, Yb, Zb);
% done

end
