function [dataflow, prmflow, status] = reconnode_offfocalhelical(dataflow, prmflow, status)
% recon node, off-focal correction for helical
% [dataflow, prmflow, status] = reconnode_offfocalhelical(dataflow, prmflow, status);

% Copyright Dier Zhang
% 
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
% 
%     http://www.apache.org/licenses/LICENSE-2.0
% 
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

% not prepared?
if ~status.pipeline.(status.nodename).prepared
    [dataflow, prmflow, status] = reconnode_offfocalprepare(dataflow, prmflow, status);
    status.pipeline.(status.nodename).prepared = true;
end

% parameters to use in prmflow
Nview = prmflow.raw.Nview;
Nslice = prmflow.raw.Nslice;
Npixel = prmflow.raw.Npixel;
Nviewprot = prmflow.raw.Nviewprot;
% prepared parameters
prmoff = prmflow.raw.offfocal;
slicemerge = prmoff.slicemerge;
Nslicemerge = Nslice/slicemerge;
Noffsample = prmoff.Noffsample;
Nviewoff = prmoff.Nviewoff;
slicezebra = prmoff.slicezebra;

% step1 exp
dataflow.rawdata = 2.^(-dataflow.rawdata);

% % reshape
% dataflow.rawdata = reshape(dataflow.rawdata, Npixel*Nslice, Nview);

% if slicemerge>1
%     if ~slicezebra
%         Aoff = squeeze(mean(reshape(dataflow.rawdata, Npixel, slicemerge, Nslicemerge, Nview), 2));
%     else
%         Aoff = reshape(mean(reshape(dataflow.rawdata, Npixel, 2, slicemerge, Nslicemerge/2, Nview), 3), ...
%                 Npixel, Nslicemerge, Nview);
%     end
% else
%     Aoff = reshape(dataflow.rawdata, Npixel, Nslice, Nview);
% end
% 
% % off-focal view index
% index_voff = ((prmoff.offstartview : prmoff.offendview) - 1).*prmoff.viewsparse + 1;
% 
% 
% % interp raw0 to off-focal measure space
% offraw = zeros(Noffsample, Nslicemerge, Nviewoff, 'single');
% for islice = 1:Nslicemerge
%     Df = index_voff - prmoff.rawinterp2phi;
%     Df(Df<1) = 1;   Df(Df>Nview) = Nview;
%     offraw(:, islice, :) = interp2(squeeze(Aoff(:, islice, :)) , Df, repmat(prmoff.rawinterp2t(:, islice), 1, Nviewoff), 'linear', 0);
% end
% 
% % conv
% offraw = ifft(fft(reshape(offraw, Noffsample, []), Noffsample).*prmoff.offkernel);

% step2, tp off
offraw = offfocalmeasurehelicalKernelfunction(dataflow, prmflow, status);

offraw = reshape(offraw, Noffsample, Nslicemerge, []);
% view index
index_vraw = (0:Nview-1)./prmoff.viewsparse - prmoff.offstartview + 2;

% interp raw1 back to raw space
Afix = zeros(Npixel, Nslicemerge, Nview, 'single');
for islice = 1:Nslicemerge
    Dfb = index_vraw + prmoff.tinterp2phi(:, islice);
    Dfb(Dfb<1) = 1;   Dfb(Dfb>Nviewoff) = Nviewoff;
    Afix(:, islice, :) = interp2(squeeze(offraw(:, islice, :)) , Dfb, ...
        repmat(prmoff.tinterp2raw(:, islice), 1, Nview), 'linear', 0);
end

1;
% measure scale
Afix = Afix.*prmoff.Dphiscale;
Afix = real(Afix) + imag(Afix).*prmoff.Dphiscale_odd;

% permute Afix to move the slice to dim 1
Afix = reshape(permute(Afix, [2 1 3]), Nslicemerge, []);
% inverse slice merge
if slicemerge>1
    Afix = repelem(Afix, slicemerge, 1);
    if slicezebra
        Afix = reshape(permute(reshape(Afix, slicemerge, 2, []), [2 1 3]), Nslice, []);
    end
end

% Z cross
if ~slicezebra
    Afix = prmoff.crsMatrix * Afix;
else
    Afix(1:2:end, :) = prmoff.crsMatrix * Afix(1:2:end, :);
    Afix(2:2:end, :) = prmoff.crsMatrix * Afix(2:2:end, :);
end

% reshape
Afix = reshape(permute(reshape(Afix, Nslice, Npixel, Nview), [2 1 3]), Nslice*Npixel, Nview);

% add to rawdata
dataflow.rawdata = dataflow.rawdata - Afix;

% minimum boundary
minintensity = prmflow.raw.offfocal.minintensity;
dataflow.rawdata(dataflow.rawdata<minintensity) = minintensity;
% log2
dataflow.rawdata = -log2(dataflow.rawdata);

% % reshape
% dataflow.rawdata = reshape(dataflow.rawdata, Npixel*Nslice, Nview);

% status
status.jobdone = true;
status.errorcode = 0;
status.errormsg = [];
end